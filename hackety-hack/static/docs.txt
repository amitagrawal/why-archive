= Hackety Hack =

Using Hackety Hack is much more than just using Ruby.  It's a world of icons and
mini-browsers in here.  Great stuff, but it begs for an explanation, you know?

This page goes over the basics of what to click on.  The menu on the left has a few other
pages (such as the '''Channel''' and '''Hacker'''  sections) which cover commands that
are special to H-ety H.

==== Hey, Use That Handy Program Menu! ====

!screenshot-help-progdrop.png!

On Hackety Hack's home screen, you have a list of your saved programs.  The program
menu for each of these will let you '''Run''', '''Share''' or '''Delete''' any of your
programs.  Running and sharing are the best!

 * '''Run this''' will start the program right there, on the spot.  This is just a handy
   shortcut for programs that work well, stuff that you've already finished.
 * '''Share this''' will pass the program up to the Hackety Hack site.
 * '''Delete this''' will get rid of the program FOREVER!  Be careful!  (If you've shared
   the program, it'll still be shared on the Hackety Hack site, though.)

==== Oh, Tables Have One, Too ====

!screenshot-help-tabledrop.png!

For tables, you've got a slightly shorter menu, trimmed down to just '''Share''' and
'''Delete'''.

Sharing tables is a bit different.  You can only share a table once.

!\screenshot-help-tablelink.png!

The first time you share a table, it is copied to your hacketyhack.net site.  After
that, the program shows up with a little chain link icon.  This means that the table
is shared already.

==== Making It Personal ====

!\screenshot-help-setuplink.png!

Hackety Hack has just a few personal settings you'll need to fill in, to get the
full experience.

To change your personal settings, hit the home icon on the toolbar.  Once on the
home screen, look for the '''Your Setup''' link under the Hacky Mouse picture.
Yeah, good, click on that.

The setup screen looks like this:

!screenshot-help-setup.png!

With only two sections, there's really not much to the setup page.

 * The '''HacketyHack.net Login''' section is where you put your username and password
   for the hacketyhack.net site.  If you don't have an account, [[http://hacketyhack.net/signup/ get one]]!
 * The '''HTTP Proxy''' section is normally not needed.  Certain schools and workplaces
   use an HTTP proxy to get to the Internet.  If you're behind a proxy, you'll need
   to fill this in or all the Web library stuff won't work for you!

Oh, and about HTTP proxies: use a full HTTP url.  So, if your proxy is at `proxy.com` and port `9009`,
you'd use the URL:

{{{
 http://proxy.com:9009/
}}}

If your proxy has a username and password, add that to the URL like this:

{{{
 http://username:password@proxy.com:9009/
}}}

== Built-in Methods ==

These methods can be used anywhere throughout Hackety Hack programs.

All of these commands are unusual because you don't attach them with a dot.  '''Every other method in this
manual must be attached to an object with a dot.'''  But these are built-in methods (also called: Kernel
methods.)  Which means no dot!

A common one is `puts`:

{{{
 #!ruby
 puts "No dots in sight"
}}}

Compare that to the method `reverse`, which isn't a Kernel method and is avaiable with Arrays and Strings:

{{{
 #!ruby
 "Plaster of Paris".reverse
   #=> "siraP fo retsalP"
 [:dogs, :cows, :snakes].reverse
   #=> [:snakes, :cows, :dogs]
}}}

=== ask( message ) ===

Pops up a window and asks a question.  For example, you may want to ask someone their name.

{{{
 #!ruby
 name = ask("Please, enter your name:")
}}}

When the above script is run, the person at the computer will see a window with a blank box for entering their name.  The name will then be saved in the `name` variable.

=== ask_color(title: a String) ===

Pops up a color picker window.  The program will wait for a color to be picked, then gives you 
back a Color object.  See the `Web.page` help for some ways you can use this color.

{{{
 #!ruby
 backcolor = ask_color("Pick a background")
 Web.page do
   body do
     style('background-color' => backcolor)
   end
 end
}}}

=== ask_open_file() ===

Pops up an "Open file..." window.  It's the standard window which show all of your folders and lets you select a file to open.  Hands you back the name of the file.

{{{
 #!ruby
 filename = ask_open_file
 puts File.read(filename)
}}}

=== ask_save_file() ===

Pops up a "Save file..." window, similiar to `ask_open_file`, described above.

{{{
 #!ruby
 save_as = ask_save_file
}}}

=== exit() ===

Stops your program.  Call this anytime you want to suddenly call it quits.

=== print( message, message, ... ) ===

Write something on the Hackety Hack program page.  Every program has a hidden page which can be written on.  When the program is done, this page appears.  You can use this page to show a report of everything the program did.  Or you can build a page with links to other programs or files.

{{{
 #!ruby
 print "The program is done.  Now everyone can go home."
}}}

=== puts( message, message, ... ) ===

A variation on `print`.  The `print` method writes messages on one long line.  The `puts` method, however, will write each of its messages on a separate line.

{{{
 #!ruby
 puts "Hi.", "Hello.", "Anyone there?"
}}}

The code above will print each message on its own line.

{{{
 Hi.
 Hello.
 Anyone there?
}}}

=== p( obj, obj, ... ) ===

The `p` method helps you see what kinds of objects you're dealing with.  If you have an object in the `stuff` variable, you can use `p` to find out what's inside.

{{{
 #!ruby
 stuff = Web.fetch("http://feeds.feedburner.com/boingboing/iBag")
 p stuff
}}}

In the above example, the `Web.fetch` method is use to get a feed for the Boing Boing blog.

{{{
 (Web::Feed "Boing Boing")
}}}

Sure enough, the `stuff` variable has a feed in it!

=== say( message ) ===

When a program is running, a little barbershop pole spins with a message that reads "Running...".  If your program is running for awhile, you may want to change that message.  Maybe you'll want to let the person at the computer know that you're 50% done.

{{{
 #!ruby
 say("Okay, I'm 50% done.")
}}}

Once your program is finished, the message and the barbershop pole will disappear.

== Address ==

An Address identifies a spot in the world.  For now, this is a bit primitive and uses
just a simple Yahoo! map.

Addresses are created with a string.  For U.S. addresses, give the street address, city and
state.  Lots of abbreviations work, just try it and see!

{{{
 #!ruby
 motel = Address("606 E 27th, Scottsbluff, NE 69361")
 puts motel
}}}

Google Maps conflicts with Hackety Hack in some dark way, but I hope this'll get better
one day.

== The Channel object ==

Channels give hackers a way to pass messages back and forth to each other.  Every hacker signed
up at hacketyhack.net can set up their own channels.

To connect to the central test channel:

{{{
 #!ruby
 chan = Hacker('central').channel('test')
}}}

The `chan` variable now contains a Channel object, which can be used to send messages and
read messages.

{{{
 #!ruby
 chan.say("Anyone around?")
}}}

Any Ruby object can be sent to the channel.  This means you can send pictures, for example.
Or an Address.

{{{
 #!ruby
 chan.say(Picture("C:/test.jpg"))
 chan.say(Address("6 Delancey St, New York, NY 10002"))
}}}

=== hear() ===

Get all unread messages from the channel.

{{{
 #!ruby
 chan.hear().each do |message|
   puts(message)
 end
}}}

=== name() ===

The name of this channel, as a String.

{{{
 #!ruby
 chan = Hacker('why').channel('lobby')
 chan.name()  #=> "lobby"
}}}

=== owner() ===

The name of the hacker who owns this channel.

{{{
 #!ruby
 chan = Hacker('why').channel('lobby')
 chan.owner()  #=> "why"
}}}

=== say( Object ) ===

Send a message to the channel.

{{{
 #!ruby
 chan.say("Anyone around?")
}}}

=== start() ===

Starts the channel, if it's never been used before.  In order to start the
channel, it needs to be under your Hackety Hack username.

{{{
 #!ruby
 Hacker('test').channel('brandnew').start
}}}

== Picture ==

Picture objects are a way of showing pictures stored on your computer.

{{{
 #!ruby
 icon = Picture("C:/my-icon.gif")
 puts icon
}}}

== The Hacker class ==

Hacker objects let you use code or messages by other hackers.

{{{
 #!ruby
 Hacker('why').load_program('youtube.rb')
}}}

== The Table library ==

Tables are for storing a list of things which are similiar.  For instance: a blog.

Blog entries are similiar: they each have a title and a main area.  You could store a series of
blog entries in a single table.

Also see `Web.popup(name)`, which automatically creates tables which are attached to
popups.

=== all() ===

Makes an Array of all the items you've selected.  You can also use `each`
to move through the items in order.

=== each() { |item| } ===

Moves through each item you've selected.

{{{
 #!ruby
 Table("Blog").recent(10).each do |entry|
   puts entry[:title]
 end
}}}

In this example, the `each` honors the fact that I've selected
the ten latest blog entries using the `recent` method.

=== first() ===

Gets the first item in the table from among the items you've
selected.  The item is returned as a Hash.

=== last() ===

Gets the last item in the table from among the items you've
selected.  The item is returned as a Hash.

=== limit( a Number ) ===

Trims down the number of items you're getting.

=== only( a Number ) ===

Gets a specific item from the Table using its ID.

{{{
 #!ruby
 entry = Table("Blog").only(6)
 puts entry[:title]
}}}

=== recent( a Number ) ===

Gets the most recent items from the Table.

{{{
 #!ruby
 entries = Table("Blog").recent(10)
}}}

This will load the ten most recent entries from the `Blog` table.

The `recent` method is actually just a shortcut for using `order`
and `limit` together:

{{{
 #!ruby
 entries = Table("Blog").order("Created DESC").limit(num)
}}}

=== save( a Hash ) ===

Saves a single item to the table.

{{{
 #!ruby
 Table("ToDo").save(:what => "Make coconut curry",
   :finished => false, :difficulty => 4)
}}}

The item must be expressed as a Hash, as seen above.  The Hash keys
(such as `:what`, `:finished` and `:difficulty`) set up a pattern for
all `ToDo` items.  The next time something gets saved to the `ToDo`
table, this pattern should be followed again.

{{{
 #!ruby
 id = Table("ToDo").save(:what => "Get box springs",
        :finished => true, :difficulty => 1)
}}}

When you `save`, you get back an `id`, a Number for this item.  When
you save the first time, you get back 1.  The next time, you get back
2.  This number is needed when you use the `only` method.

There are a few special keys that you can't save to.  These three are:
`:id`, `:created`, and `:updated`.  The `:id` we just talked about.
The `:created` key tells you the time when this item was first saved.
The `:updated` key is the time of the last update.

{{{
 #!ruby
 latest_entry = Table("ToDo").recent(1).first
 puts latest_entry[:created]
}}}

== Video ==

Video objects allow you to show videos stored on your computer.

{{{
 #!ruby
 puts Video("video.flv")
}}}

= Ruby =

Hackety Hack comes with a pile of handy extra stuff.  But the Standard Library has
all the things that normally come with the Ruby language itself.  Very basic and
fundamental things like numbers and lists.

You can find a nice, short glance at all the parts of Ruby on the Hackety Hack
cheat sheet, which can be found by clicking the magic wand icon in the toolbar.

== Special Types ==

Ruby has three special types: `nil`, `true` and `false`.

=== nil ===

Nil is one of a kind.  Literally, it means "nothing".  Nil is a good thing to put in a
variable if you really want that variable to be blank.

Lots of Ruby methods return `nil`.  Most of the time it means "nothing was found"
or "nope, that does nothing."  It's a safe way of giving back nothing rather than tossing
an error (which could stop your whole program.)

{{{
 #!ruby
 list = [1, 2, "January", [3, 4, 5]]
 found = list.detect { |x| x == "February" }
  #=> nil
}}}

In this example, we're searching the list for the string `"February"`.  Nil comes back.
A prime example of "nothing was found."

You can check for `nil` by using `if`.

{{{
 #!ruby
 if found
   puts "Found February!"
 end
}}}

Nil has a handful of methods!  Because: everything in Ruby is an object.  This means
everything is a useful thing which has its own actions (called methods.)

One method, `nil?` is on every object.  But it only says `true` on the one and
only actual `nil`.

{{{
 #!ruby
 if found.nil?
   puts "The `found` variable is really nil!"
 end
}}}

=== true and false ===

The `true` and `false` types are yin and yang, yes and no, positive and negative.

One important place to use these two are in an `if`.

{{{
 #!ruby
 if tivo_shows.include?("The Colbert Report")
   puts("Oh, good, The Colbert Report is recording")
 end
}}}

In the example above, we have a list of TV shows in `tivo_shows` variable.
We use the `include?` method to find a certain show.  Since `include?` gives
us a yes or no (true or false,) it's perfect for an `if` statement.  The `if`
will let us in if the show is found.

Methods like `Array.detect`, `Hash.has_key?` and `File.exists?` all give back
true or false.  If the method has a question mark at the end, it usually deals
only in true or false.

Couple these with an `if` in your program.

== Array ==

An Array is a list of things.  Especially useful when you have some things you
want to keep in a specific order.

Create a new Array by using square brackets to surround a list of items.  Remember it
as a caterpillar which is stapled into your code.  The square brackets are the staples
at each end.  The commas between each items are the legs of the caterpillar.

{{{
 #!ruby
 soap_brands = ["Zest", "Irish Spring", "Dove"]
}}}

Arrays can be easily added to with the `push` method.  Or the `<<` operator, which
is a symbol meaning "push".

{{{
 #!ruby
 soap_brands.push "Lava"
 soap_brands << "Ivory"
}}}

Arrays start their counting at zero.  This means the first item in the list is at position zero.

{{{
 #!ruby
 feed = Web.fetch("http://redhanded.hobix.com/", :as => Web::Feed)
 feed.items = [feed.items[0], feed.items[1], feed.items[3]]
}}}

The above code makes a new Array from the first, second, and fourth items in the feed.

Oh, one other thing.  You can also use negative positions, which count from the end of
the list.  So, `-1` is the position of the last item.  And `-2` is the second to last item
and so on.

{{{
 #!ruby
 puts soap_brand[-1]
}}}

=== array + array ===

Arrays can be added together with the plus sign.  A new array is given
back with the items from the first list, followed by the item from the
second list.

{{{
 #!ruby
 robots = ["Trurl", "Klapaucius"] + ["R2-D2", "C-3PO"]
 robots  #=> ["Trurl", "Klapaucius", "R2-D2", "C-3PO"]
}}}

=== array - array ===

Arrays can actually be subtracted, too!  A new array is made from all
the stuff in the first array and anything is removed which is also found
in the second array.

{{{
 #!ruby
 numbers = [1, 2, 3, 4, 5, 6]
 evens = [2, 4, 6]
 numbers - evens  #=> [1, 3, 5]
}}}

=== << an Object ===

Add any object to the end of an array with the double-angle.  This is
often called the "concatenator."

{{{
 #!ruby
 fruit = ["apples", "mangos"]
 fruit << "pineapple"
 fruit.length   #=> 3
}}}

=== [ position: a Number ] ===

Gets an item at a certain position.  Arrays start at zero, so `array[0]` will give you the
first item from the Array.

{{{
 #!ruby
 huxtables = ["Heathcliff", "Clair", "Denise", "Theo", 
              "Vanessa", "Rudy"]
 huxtables[0]     #=> "Heathcliff"
 huxtables[-1]    #=> "Rudy"
}}}

As shown in the last line, negative positions can be used.

If nothing is at that position, `nil` is returned.

=== [ position: a Number ] = an Object ===

You can place an object at a specific position by dropping an equal
sign after the square bracket.

{{{
 #!ruby
 list = ["take a jog", "go swimming"]
 list[1] = "swimming is cancelled"
}}} 

If nothing is at that position, `nil` is returned.

=== [ from: a Number .. to: a Number ] ===

Makes a new array from a small section of this array.  Starting at position
`from` and going until the `to` position.

{{{
 #!ruby
 sites = [:H, :A, :C, :K, :E, :T, :Y]
 sites[2..-2]    #=> [:C, :K, :E, :T]
}}}

This example starts at position 2 (where `:C` is) and grabs everything up to
position -2, which is the second-to-last object in the array (the `:T`).

If you happen to use numbers which go past the end of the array, Ruby will
halt at the end.  If nothing is found between the positions, you'll get
back `nil` (as in "nothing was found.")

=== [ start: a Number, how_many: a Number ] ===

Makes a new array by extracting some items from this array.  Starting at
position `start` and grabbing the number of items described by `how_many`.

{{{
 #!ruby
 sites = ["yahoo.com", "google.com", "msn.com", "technorati.com"]
 sites[1, 2]    #=> ["google.com", "msn.com"]
}}}

This example starts at position 1 (where "google.com" is) and grabs two items
into a new array.

If you try to grab anything past the end of the array, Ruby will stop at the
array's end.  If nothing is found from the starting point onward, you'll get
back a `nil`.

=== at( position: a Number ) ===

Gets an item at a certain position.  Works just like `array[position]`, described earlier.

{{{
 #!ruby
 huxtables = ["Heathcliff", "Clair", "Denise", "Theo", 
              "Vanessa", "Rudy"]
 huxtables.at(0)     #=> "Heathcliff"
 huxtables.at(-1)    #=> "Rudy"
}}}

=== clear() ===

Empties the array.  Supposedly, so you can start filling it again.

{{{
 #!ruby
 list = File.readlines('README.txt')
 list.clear    #=> []
}}}

=== collect() { |item| ... } ===

A block must be attached to the `collect` method.  The block loops through the Array
and hands each item into the block.  Whatever the block hands back is placed back into
a new array at that same position.  This is a great way to edit each item in an Array!

{{{
 #!ruby
 dogs = ["Pluto", "Astro", "Benji", "Lassie"]
 updogs = dogs.collect { |item| item.upcase }
 updogs
  #=> ["PLUTO", "ASTRO", "BENJI", "LASSIE"]
 dogs
  #=> ["Pluto", "Astro", "Benji", "Lassie"]
}}}

So, it doesn't change the first Array.  See?  It just makes a new Array, based on the old one.

If you want to make a slightly different copy of an Array, `collect` (also called `map`)
is a great place to start.

=== collect!() { |item| ... } ===

Just like `collect` above: the block handles every item in the Array and changes the item.
But instead of making a new Array, it changes the Array itself.  Which is why this method
has an exclamation mark.  It's dangerous: it'll replace everything in the Array!

{{{
 #!ruby
 dogs = ["Pluto", "Astro", "Benji", "Lassie"]
 dogs.collect! { |item| item.length }
 dogs
  #=> [5, 5, 5, 6]
}}}

See, the Array was overwritten.  With the length of each item.  And, in a dangerous way:
all the dog's names... are gone.

=== compact() ===

Removes all the `nil`s from the Array.  In case you want only things of substance.
I mean what is `nil` good for anyway?

{{{
 #!ruby
 ["a", nil, "b", nil, "c", nil].compact
  #=> ["a", "b", "c"]
}}}

=== concat( an Array ) ===

Adds an Array to the end.

{{{
 #!ruby
 ["ducks", "mule"].concat( ["sheep", "cats"] )
  #=> ["ducks", "mule", "sheep", "cats"]
}}}

Incidentally, you can also use `+=` to do the same thing.

{{{
 #!ruby
 animals = ["ducks", "mule"]
 animals += ["sheep", "cats"]
}}}

=== delete( an Object ) ===

Deletes anything from the array that is equal to the object passed in.

=== delete_if { |item| ... } ===

A block is attached to `delete_if` which cycles through each item in
the array.  If the block gives back `nil` or `false`, then the item
is deleted from the array.  A new array is made without any of the
deleted objects.

So: `array.delete_if { nil }` gets rid of everything!

But: `array.delete_if { |x| x.even? }` would get rid of even numbers
in a list made entirely of numbers.

=== each { |item| ... } ===

One of the most common things you can do with an array is to run
the `each` method.  The block attached will get each of the items
in the array, one-by-one, in order.  The nice thing about this is
that you don't need to how long the array is, `each` will start at
the start and end at the end.

So, for example, if you want to show each item in an array:

{{{
 #!ruby
 array.each { |item| puts item }
}}}

In programming, this concept of cycling through a list from
start to end is called a "loop."

=== first() ===

Gives back the first item in the array.  Simple!

=== include?( an Object ) ===

Searches the array for an object.  It asks, "is this object
included in the array?"  And you get back either `true` or
`false`.

{{{
 #!ruby
 robots = ["Trurl", "Klapaucius", "R2-D2", "C-3PO"]
 robots.include?("R2")       #=> false
 robots.include?("R2-D2")    #=> true
}}}

=== index( an Object ) ===

So you want to find the position of an object in a list.
The `index` method does just that.  If it finds the object
in the array, it'll give you the number of its position.

Otherwise, you'll get a `nil`.  Which means "nothing was
found."

{{{
 #!ruby
 animals = ["bears", "rabbits", "panthers"]
 animals.index("rabbits")  #=> 1
 animals.index("MAMMOTHS") #=> nil
}}}

=== join( separator: a String ) ===

Makes a string from the array.  The `separator` string will
be placed between each item.

{{{
 #!ruby
 ["bears", "rabbits", "panthers"].join(" & ")
   #=> "bears & rabbits & panthers"
}}}

See, it's great for putting together sentences.

=== last() ===

Gives back the last item in the array.  In case you're
curious.

=== length() ===

How long is the array?  The `length` method gives back
a number.  Zero if it's empty.

=== map() { |item| ... } ===

An alias for `collect`, which was described earlier on this page.

=== map!() { |item| ... } ===

An alias for `collect!`, check it out, it's up higher on this page.

=== reverse() ===

Makes a new array with all items in the opposite order.  So, if you
have a list of blog entries from newest to oldest, you can use this
to switch from oldest to newest.

{{{
 #!ruby
 Table('Blog').recent(10).reverse()
}}}

This is also great with `sort()`.  If you want a list of A to Z, you
can reverse it to get Z to A.

{{{
 #!ruby
 cats = ["Sylvester", "Boo", "Tom"]
 cats.sort().reverse()
   #=> ["Tom", "Sylvester", "Boo"]
}}}

=== sort() ===

Returns a new array with its contents sorted.  For most things, this
just works.  Strings get sorted alphabetically.  Numbers get sorted
from zero up.

{{{
 #!ruby
 cats = ["Sylvester", "Boo", "Tom"]
 cats.sort()
   #=> ["Boo", "Sylvester", "Tom"]
}}}

How does it know how to sort things, though??  Well, it uses the spaceship
method!  The spaceship method looks like this: `<=>`.  It's used to tell
how to order two things.

{{{
 #!ruby
 "Sylvester" <=> "Boo"
   #=> 1
}}}

An answer of `1` means the items are out of order.  So "Boo" needs to
go first.

Anyway, the important things is: anything which has the spaceship method
can be sorted.

=== to_a() ===

Gives back this array.

=== to_ary() ===

Once again, gives back this array.  No need to turn it into an array,
it already is one.

=== to_s() ===

Turns the array into a new string by calling `join()`.  But since
there's no separator, all the items are smashed together in the
new string.

{{{
 #!ruby
 animals = ["bears", "rabbits", "panthers"]
 animals.to_s  #=> "bearsrabbitspanthers"
}}}

== Dir ==

Dir is short for "directory."  Which means: a folder on your hard drive.
Use Dir to list files inside folders.

{{{
 #!ruby
 Dir["#{DOWNLOADS_DIR}/*"].each do |filename|
   puts filename
 end
}}}

There are really only two common things you can do with Dir.  In the above
example, we listed all the files in the folder using a "glob."  You can also
create new folders with `Dir.mkdir`.

=== Dir[ glob: a String ] ===

Lists files in a directory.  So, you get back an array of strings -- a list
of file names.  There are a few special things to know, though.

First, you can use an asterisk, which is a wildcard for "any filename".

{{{
 #!ruby
 Dir["*"].each do |item|
   puts "#{item} is #{File.size(item)} bytes big"
 end
}}}

Secondly, you can use curly braces to give a list of words to match.  So, if
you want to match any files that are MP3s or M4As:

{{{
 #!ruby
 Dir["*Ghost.{mp3,m4a}"] #=> ["Tuff Ghost.mp3", "Sea Ghost.mp3"]
}}}

=== Dir.mkdir( name: a String ) ===

Makes a new, empty folder.

{{{
 #!ruby
 Dir.mkdir('C:/Hacks')
}}}

== File ==

A File is a file on your hard drive.  Like a text file or an email or an MP3
that you've saved.

You can get inside a file by using `File.open`.  Here, let's open a new file
called "To Do.txt":

{{{
 #!ruby
 File.open("To Do.txt", "w") do |f|
   f << "Stock up on coconut milk."
 end
}}}

The `"w"` part is used to ask Ruby to open the file for writing.  So we could 
add an item to the new to-do list.

The `f` variable given to the block is a File object.  So, once opened, the File
can use any of the methods below.

{{{
 #!ruby
 insides = File.open("To Do.txt", "r") do |f|
   f.read()
 end
 puts(insides)
}}}

The `"r"` mode is for reading files.

(!) '''IMPORTANT NOTE:''' On Windows, normal files are treated like text files.  If you'll
be opening up an image (a GIF or JPEG) or any file which doesn't have plain text
words inside, be sure to read in binary mode `"rb"` or write in binary mode `"wb"`.

{{{
 #!ruby
 File.open("stinky-the-skunk.png", "rb") do |f|
   puts "Image is #{f.read().length()} bytes long."
 end
}}}

Don't forget about `ask_open_file` and `ask_save_file` from the Built-in list.
They go great with File objects!

=== File.basename( filename: a String ) ===

Give this method a full filename (like `"C:/WINDOWS/notepad.exe"`) and it'll
give you back just the basic filename, stripped of the folder names (such as
`"notepad.exe"`.)

{{{
 #!ruby
 comics = "C:/Documents and Settings/Philarp/My Documents/comics.txt"
 File.basename(comics)   #=> "comics.txt"
}}}

=== File.delete( filename: a String ) ===

Deletes a file, permanently.

{{{
 #!ruby
 File.delete("D:/Vids/Good-Burger.mov")
}}}

=== File.dirname( filename: a String ) ===

Give this method a full filename (like `"C:/WINDOWS/notepad.exe"`) and it'll
give you back just the folder names (so: `"C:/WINDOWS"`)

{{{
 #!ruby
 comics = "C:/Documents and Settings/Philarp/My Documents/comics.txt"
 File.basename(comics)   #=> "C:/Documents and Settings/Philarp/My Documents"
}}}

=== File.exists?( filename: a String ) ===

Checks to see if a file is really there, on your hard drive.  Since it's
got a question mark -- that's right -- you only get `true` or `false`
out of this.

{{{
 #!ruby
 if File.exists?("C:/corn-cob.png")
   puts "Why you keep pictures of corn cobs lying around -- I'll never know."
 end
}}}

=== File.join( a String, a String, ... ) ===

Glue together any number of strings, adding slashes between them.  So
this is a good way to build filenames.

{{{
 #!ruby
 File.join("C:", "Robots", "Trurl.txt")
   #=> "C:/Robots/Trurl.txt"
}}}

=== File.open( filename: a String, mode: "r", "w", "rb" or "wb" ) { |file| ... } ===

Opens a file for reading or writing.  Use "r" to read from a normal text file or
"w" to write to a text file.  Add the "b" to read and write from binary files (things
like images and MP3s, which don't contain plain words.)

{{{
 #!ruby
 # This program saves all chat messages in why's lobby.
 c = Hacker('why').channel('lobby')
 loop do
   f = File.open("C:/Chat.txt")
   chan.hear.each do |m|
     f.write "#{m.hacker} said at #{m.at}:\n#{m.object}\n"
   end
   f.close
   sleep 5
 end
}}}

Even better, you can use a block to automatically close the file for you.  See how
I had to use `close` when I was done writing?  If you use a block, the file will close
when you hit the end of the block.

Like this:

{{{
 #!ruby
 File.open("C:/Chat.txt") do |f|
   chan.hear.each do |m|
     f.write "#{m.hacker} said at #{m.at}:\n#{m.object}\n"
   end
 end
}}}

The block is far superior, use it for sure!

=== File.rename( from: a String, to: a String ) ===

Changes the name of a file.  Moves it.

{{{
 #!ruby
 File("basil-kirchin.mp3", "Quantum-Part-1.mp3")
}}}

This will rename the MP3 from `basil-kirchin.mp3` to its new
name `Quantum-Part-1.mp3`.  Handy for cleaning up your music
and photo collections.

=== File.size( filename: a String ) ===

Measures the size of a file in bytes.

{{{
 File.size("Adventure Time.flv")
   #=> 18814749
}}}

So, `Adventure Time.flv` is 18,814,749 bytes large.  Or, roughly, 18 megabytes.

=== << a String ===

Write a message to the file with the double-angle.  This is identical to
using `write`, but can be helpful to those of you who like visual symbols
instead of words.

{{{
 #!ruby
 File.open("FavoriteTreats.txt", "w") do |f|
   f << "Pickle Surprise"
 end
}}}

=== close() ===

Closes the file.  This notifies the computer that you are done with the
file and are moving on to other things.  One good reason to close a file
is so other programs can use it.

{{{
 #!ruby
 f = File.open("GiraffeNames.txt")
 puts "I like giraffe names.  For example:"
 puts f.read
 f.close
 puts "And that's all of them!"
}}}

If you're using a block, then don't bother!  The block will close the file
for ya.  See the help for `File.open`, if you want to see an example.
 
=== read() ===

Store everything inside the file in a string.

{{{
 #!ruby
 File.open("GiraffeNames.txt") do |f|
   names = f.read
 end
}}}

Assume `GiraffeNames.txt` is a plain text file.  Like this:

{{{
 Chopsy
 McCoy
 Beanback
 Shlomi
}}}

And we hack like this:

{{{
 #!ruby
 f.read
   #=> "Chopsy\nMcCoy\nBeanback\nShlomi\n"
 f.read
   #=> ""
}}}

The `read` method will start at the top of the file and read until it
hits the bottom.  Which means if you try to `read` after it hits the bottom,
you won't get anything back.

Try using the `rewind` method to go back to the beginning and start again.

Oh, one other thing: you can give `read` a number.  And it'll stop once it's read
that many letters.  Or, I should say, bytes.

{{{
 #!ruby
 f.read(6) # read only the first six letters
   #=> "Chopsy"
}}}

=== readlines() ===

Just like `read`, we get back the entire file.  But this time as an Array full of
Strings.  And each string contains a line from the file.

Using the `GiraffeNames.txt` mention in the `read` example above:

{{{
 #!ruby
 f.readlines
   #=> ["Chopsy\n", "McCoy\n", "Beanback\n", "Shlomi\n"]
 f.readlines
   #=> []
}}}

=== rewind() ===

Moves back to the top of the file.  When you open a file, you always start
at the top, so you don't need to use this unless you've already done some
reading or writing.

{{{
 #!ruby
 f.read
   #=> "Chopsy\nMcCoy\nBeanback\nShlomi\n"
 f.rewind
 f.read
   #=> "Chopsy\nMcCoy\nBeanback\nShlomi\n"
}}}

=== write( text: a String ) ===

Adds the `text` string to the file.  Also see the `<<` method up above, it
is identical.

{{{
 #!ruby
 File.open("FavoriteTreats.txt", "w") do |f|
   f.write "Pickle Surprise"
 end
}}}

== Fixnum ==

A Fixnum is a number.  1, 2 and 3.  And so on!

Oh, and negative numbers, too.

{{{
 #!ruby
 4 + 6      # add
   #=> 10
 14 - -2    # subtract
   #=> 16
 12 / 2     # divide
   #=> 6
 200 * 3    # multiply
   #=> 600
}}}

Hopefully you won't be doing much math, though.  More commonly, you'll
use a number to repeat a code block over-and-over, using the `times`
method.

Like, to repeat a block five times:

{{{
 #!ruby
 5.times do
   puts "Odelay!"
 end
}}}

Which will print '''Odelay!''' five times.  Very nice, very easy to
understand.

One other thing that could be helpful.  If you have a number inside
a variable, you can add to it with the `+=` sign.

{{{
 #!ruby
 num = 6
 num += 1
  # now `num` is 7
}}}

Most languages use `++` for this.  But forget about that for now, okay?

=== abs() ===

Take off the negative sign.  This is called the number's "absolute value".

{{{
 #!ruby
 -16.abs
   #=> 16
}}}

=== downto( bottom: a Number ) { |number| } ===

Counts from this number to the number at the `bottom`.  Each count,
the next number down is given to the block.

{{{
 #!ruby
 puts "Counting down:"
 10.downto(1) do |number|
   puts "#{number}!!"
 end
 puts "Yay, my hat is now on fire."
}}}

=== times { |number| } ===

Counts from zero up to this number.  Each count, the block gets
the number we're at.

{{{
 #!ruby
 5.times do |i|
   puts "Odelay!! (#{i})"
 end
}}}

=== to_s() ===

Converts a number to a string so you can print it on the screen or
store it in a table or something.

{{{
 #!ruby
 5.to_s
   #=> "5"
}}}

=== upto( top: a Number ) { |number| } ===

Counts from this number up to the number at the `top`.  Each count,
you get the next number up the ladder, which is given to the block.

{{{
 #!ruby
 puts "Counting up:"
 1.downto(10) do |number|
   puts "#{number}!!"
 end
 puts "I AM CHAMPION."
}}}

== Hash ==

A Hash is a dictionary of pairs.  Meaning: it pairs up things.  You'd be
surprised how often this comes up.

Like whenever you see this:

{{{
 #!ruby
 Web.fetch('http://metafilter.com', :as => Web::Feed)
}}}

That last part is a Hash.  The part that says: `:as => Web::Feed`.
It can also be written like this:
 
{{{
 #!ruby
 Web.fetch('http://metafilter.com', {:as => Web::Feed})
}}}

When you're building hashes outside of a method, though, you'll use an opening and
a closing curly brace:

{{{
 #!ruby
 books = {
   "Gulliver's Travels" => :excellent,
   "A Separate Peace" => :boring,
   "Bonfire of the Vanities" => :just_not_my_style
 }
}}}

See, this is a good example of a useful hash.  This hash pairs up a book
title with how I feel about that book.  I could make a huge hash of all
the books I've read and how I feel about them.

Then, when I want to look up a certain book:

{{{
 #!ruby
 books["A Separate Peace"]
   #=> :boring
}}}

The square brackets can be used to '''look up''' a book name.

More often, in Hackety Hack, you'll keep stuff like this in a
Table.  But Tables can be loaded into a hash certainly.
Using hashes as a temporary holding place is a very common thing.

(!) '''IMPORTANT NOTE:''' Don't expect a Hash to keep things in
order!!  Hashes don't care about how things are ordered.  Use an
Array to order many things and a Hash to pair up sets of two.

Again, think of the book example.  I don't care what order the
books are in.  I just want to quickly find out what review I
gave a certain book.

=== [ lookup: an Object ] ===

This is the real purpose of a Hash.  To lookup a dictionary item.

Hashes are stored in pairs.  It's called a '''key-value pair'''.
The `key` is on the left-side of the arrow and the `value` is on the right.

Watch:

{{{
 #!ruby
 books = {"Gulliver's Travels" => :excellent}
}}}

The `key` is `"Gulliver's Travels"`.  The `value` is `:excellent`.

So, what's the big deal?  Well, when you go to look something up, you
look it up by the `key`.  It's just like in a dictionary.  You have
a word and a definition in Webster's Dictionary.  '''You look things up
by the word, not the definition.'''

To look up a book's review, we use the key:

{{{
 #!ruby
 books["Gulliver's Travels"]
   #=> :excellent
}}}

If nothing is at that look up, then `nil` is returned.  In other words,
"nothing was found."

=== [ key: an Object ] = value: an Object ===

Here's a quick way to add to a hash.  Do a look up, but set that look up
with an equals sign.

{{{
 #!ruby
 books = {}
 books["Catch 22"] = :good
}}}

=== delete( key: an Object ) ===

Deletes an entry from the hash.  Use the key, just like a look up, to
tell Ruby which entry to delete.

{{{
 #!ruby
 books = {"Alice in Wonderland" => :phenomenal}
 books.delete("Alice in Wonderland")
   #=> :phenomenal
 books["Alice in Wonderland"]
   #=> nil
}}}

=== each { |key, value| } ===

If you want to go through every entry in the hash, use `each`.
The block attached will get each pair in the hash, one-by-one,
in no particular order.

So, for example, if you want to show each pair in the hash:

{{{
 #!ruby
 books.each do |key, val|
   puts "KEY: #{key}"
   puts "VALUE: #{value}"
   puts
 end
}}}

In programming, this concept of cycling through, from
start to end, is called a "loop."

=== empty?() ===

Does this hash contain any entries?  If it does, you'll get back `false`.
Otherwise, `true`.

=== has_key?( key: an Object ) ===

Checks to see if the Hash for a `key`.  So, this is like doing a look up,
but the answer is either `true` or `false`.

{{{
 #!ruby
 books.has_key?("CivilWarLand in Bad Decline")
   #=> false
 books.has_key?("Gulliver's Travel")
   #=> true
}}}

This is especially useful if you want to make positively sure you're not
going to get `nil` back from a look up.

=== index( value: an Object ) ===

Look up not the `key` but the `value`.  So, if I want to find a book that
I gave a `:good` rating:

{{{
 #!ruby
 books.index(:good)
   #=> "Catch 22"
}}}

=== keys() ===

Builds an array from all the keys in the Hash.  If you use the dictionary
analogy, this gets a list of all the words in the dictionary that have
definitions.

Or, for our books example, a list of all the books reviewed:

{{{
 #!ruby
 books.keys
   #=> ["Gulliver's Travels", "A Separate Peace", "Bonfire of the Vanities"]
}}}

=== length() ===

How many pairs are in this hash?  A number is handed back.

{{{
 books.length
   #=> 3
}}}

Ah, so I've reviewed three books.

=== merge( hash2: a Hash ) ===

Combines this hash with another hash.  You end up with a new hash that mixes
the two.  However, if a key is found in the first hash that is also in the second
hash, then the second hash will clobber that key.

{{{
 #!ruby
 our_books = my_books.merge(daves_books)
}}}

In the above example, my books and Dave's books are combined into a single new
book review hash.  However, if Dave reviewed Gulliver's Travels, his review will
survive and mine will not.

=== merge!( hash2: a Hash ) ===

Merges the hashes, just like `merge`, but a new hash isn't created.  The second
hash is simply merged right into the first hash.

{{{
 #!ruby
 my_books.merge!(daves_books)
}}}

=== sort() ===

Sorts the hash keys alphabetically, converting the Hash to an Array, where things
are kept in order.

So, to print out my book reviews in alphabetical order:

{{{
 #!ruby
 books.sort.each do |title, rating|
   puts "#{title} was rated: #{rating}"
 end
}}}

== Object ==

Everything -- numbers, strings, arrays, etc. -- is an object.  So all of these
methods can be used on any object!  Thus this page.

A plain Object is just a blank thing, though.  You will probably never use 
Object on its own.

{{{
 #!ruby
 Object.new
   #=> (Object)
}}}

See, nothing.  Not much purpose.

=== object == object ===

Are these two objects the same?  The double-equals is hugely used throughout
Ruby.  You can test any two objects to see if they are identical.

 * `name == "Philip"` -- does the `name` variable contain a string which says "Philip"?
 * `zip_code == 34143` -- does the `zip_code` variable contain the number 34143?

This is usually attached to an `if`.

{{{
 #!ruby
 if name == "Philip"
   puts "Ah, I've been expecting you."
 end
}}}

=== class() ===

Tells you what class this object belongs to.  Is it a `String`?  Or a `Hash`?
Or a `Picture`?

{{{
 #!ruby
 "".class
   #=> String
 {}.class
   #=> Hash
 Picture("icon.png")
   #=> Picture
}}}

=== dup() ===

Makes a copy of this object.  When you create something, such as a String or an
Array, you only get one.  As you move around your program, you may change that
object or put it in new variables.  But it's still only one object really, but
perhaps with different nicknames.

The `dup` method makes a copy of the object, in case you want to mess with a
copy rather than change the object permanently.

{{{
 #!ruby
 soda = "Coca Cola"
 pop = soda.dup
 pop += "!"
   #=> "Coca Cola!"
 soda
   #=> "Coca Cola"
}}}

=== inspect() ===

Another crucial method, I say.  This method turns any object into a string.
This string usually describes everything it can about the object.  So, for
Hashes, you'll get a list of all the pairs inside the Hash.  And for an
object, you'll see all its object variables.

{{{
 #!ruby
 {"Water" => "Clear", "Milk" => "White"}.inspect
   #=> "{\"Water\" => \"Clear\", \"Milk\" => \"White\"}"
 Object.new.inspect
   #=> "(Object)"
}}}

Most often, you won't use this method directly.  You'll usually use
the built-in Kernel method called `p`.

=== is_a?( class ) ===

Checks to see if this object is a certain kind of class.  You get
back either `true` or `false`, as with all question mark methods.

{{{
 #!ruby
 "Spiderman".is_a?(String)
   #=> true
 {"Bone" => "Jeff Smith"}.is_a?(Array)
   #=> false
}}}

=== object_id() ===

This is a unique number representing this object.  You may not use this much,
but it's important to know that Ruby gives ever object its own number.

=== respond_to?( method: a Symbol ) ===

This is an incredibly helpful one!!  See, `respond_to?` checks this object
to see if it can have a certain method attached to it.

So, if you have a variable, and you want to see if it can be reversed by
using the `reverse` method:

{{{
 #!ruby
 obj.respond_to?(:reverse)
   #=> false
}}}

Oh, can't be reversed.  So let's not.

This method gives back a `true` or `false`, so it's great with an `if`.

== Regexp ==

Regexp is short for "regular expression".   A Regexp is for finding patterns in
words and paragraphs.  These suckers are not for the faint of heart!

A regular expression is usually surrounded by slashes:

{{{
 #!ruby
 r = /^image:/
}}}

This regular expression matches any string which starts with the letters
"image:".  The special caret symbol `^` represents the beginning of a line.

That's what makes regular expressions so powerful: all of the special symbols
that represent different things.  Regular expressions are their own little
language really.

==== Writing Regular Expressions ====

Here are the important symbols:

{{{
  ^  matches the beginning of a line
  $  matches the end of a line
  .  matches anything
  \d matches a number
  \w matches a letter, number or underscore
  \s matches a space, tab, or new line
  \S matches anything not a space, tab, new line
}}}

So if you want to match a 5-digit zip code: `/\d\d\d\d\d/`

Or, if you want to check if a string ends with ".mp3": `/\.mp3$/`

Notice how I put a slash in front of the dot.  Normally a dot is a
symbol matching anything.  But if I do a slash-dot `\.`, then the
dot will actually be matched.

==== Shortcuts ====

Here's a shortcut to make matching zip codes easier: `/\d{5}/`

The `{5}` means "match the last symbol 5 times".  The last symbol
was `\d` which means "a number".  So, in all: "match a number 5 times."

Here's some other shortcuts:

{{{
 {3}   match 3 times
 {3,}  match 3 or more times
 {3,5} match between 3 and 5 times
 *     match zero or more times
 +     match one or more times
 ?     match zero or one times
}}}

Now you can write some really awesome regular expressions.  For
example, to grab the first word in a sentence: `/^\w+/`

==== Examples ====

Here's a few examples that usually come up:

{{{
 #!ruby
 "pinball.mp3"[/\.\w+$/]         # match the file extension
   #=> ".mp3"
 "map:Seattle, WA"[/^map:(.+)/, 1]  # match everything after "map:"
   #=> "Seattle, WA"
}}}

=== match( a String ) ===

Try to match this regular expression '''once''' inside a string.  If a match is
found, you get a `MatchData` object.  Go ahead and convert this to an array,
using `to_a`:

{{{
 match = /^map:(.+)/.match("map:Seattle, WA").to_a
   #=> ["map:Seattle, WA", "Seattle, WA"]
}}}

If no match is found, you get back `nil`, as in "nothing was found."

I would recommend staying away from this method, though.  Use a string with
lookup `str[/regexp/]` or `str.scan(/regexp/)`.

== String ==

A String is a series of letters.  When you load a file, you pull a big long String
out of it.  A Web page is really just a String.  Anything containing words, sentences,
paragraphs is a String.

Even pictures are Strings!  (Unreadable, messy-looking Strings that is.)

To create a new String, surround your message with double quotes.

{{{
 #!ruby
 string = "I quit my job blowing leaves, 
   telephone bills up my sleeves"
 puts string
}}}

Everything in the quotes is a string, even if the string goes on for many lines.

Single quotes work as well: `'Like so.'`

=== << a String ===

Adds to the end of this string.

{{{
 #!ruby
 name = "Philarp"
 name << " Tremaine"
 puts name
   #=> Philarp Tremaine
}}}

You can chain these up, if you like:

{{{
 #!ruby
 name = "P"
 name << "h" << "i" << "l"
 puts name
   #=> Phil
}}}

=== string + string ===

Makes a new string by combining two strings, in order.

{{{
 #!ruby
 letters = "abc" + "xyz"
   #=> "abcxyz"
}}}

Generally speaking, you'll want to stay away from this and use the lilypad.

{{{
 #!ruby
 letters = "#{"abc"}#{"xyz"}"
   #=> "abcxyz"
}}}

The reason being that string addition will choke if you have a number or
something else in there.

{{{
 #!ruby
 abc = "abc"
 one = 1
 letters = abc + one
   #=> [TypeError] can't convert Fixnum into String
 letters = "#{abc}#{one}"
   #=> "abc1"
}}}

=== string[ from: a Number .. to: a Number ] ===

Grabs a part of the string and makes a new string from it.

Let's say you just want from the second letter to the fifth letter:

{{{
 #!ruby
 string[2..5]
}}}

=== string[ /regexp/: a Regular Expression ] ===

Tries to match a Regexp once in the string. The first match that's found is
returned (as a string).  Or, if none is found, then `nil` comes back.

{{{
 #!ruby
 "pinball.mp3"[/\.\w+$/]
   #=> ".mp3"
 "I have 13 rabbits!!"[/\d+/]
   #=> "13"
}}}

If you want to get a certain group from the match, you can also pass in
a number with the Regexp:

{{{
 #!ruby
 "Seattle, WA"[/(\w+), ([A-Z]+)/, 1]
   #=> "Seattle"
 "Seattle, WA"[/(\w+), ([A-Z]+)/, 2]
   #=> "WA"
}}}

See the section on `Regexp` for more about this rare and complex creature.

=== capitalize() ===

Capitalizes the first letter of the string and hands you back a copy.

=== downcase() ===

Makes a new string from this string, but with all upper-case letters
in the string changed to lower-case.  "A" becomes "a",
"B" becomes "b", and so on.

=== empty?() ===

Is this string empty?  An empty string is `""`.  If you're dealing with
an empty string, you'll get back `true`.  Otherwise, `false`.  Just like
all question mark methods.

{{{
 #!ruby
 "".empty?
   #=> true
 "OK".empty?
   #=> false
}}}

=== include?( find: a String ) ===

Checks to see if this string includes `find` somewhere inside.  It's
like a little search.

Since blog item descriptions are strings, we could use this method
to see if the most recent MetaFilter post contains the word "Colbert".

{{{
 #!ruby
 blog = Web.fetch("metafilter.com", :as => Web::Feed)
 blog.items[0].description.include? "Colbert"
   #=> false
}}}

=== ends?( ending: a String ) ===

Does this string end with this `ending`?  Great for checking file
extensions!

{{{
 #!ruby
 "Dark Star.avi".ends?(".avi")
   #=> true
 "Dark Star.avi".ends?(".mp4")
   #=> false
}}}

=== length() ===

How many characters are in this string?  This includes letters, numbers,
spaces.

{{{
 #!ruby
 "Boston".length()
   #=> 6
 "Tammany Hall".length()
   #=> 12
}}}

=== remove( phrase: a String ) ===

Makes a new string with the `phrase` removed.  This won't remove every time
the phrase appears in the string, just the first time the phrase appears.

{{{
 #!ruby
 "Beck - The New Pollution.mp3".remove(".mp3")
   #=> "Beck - The New Pollution"
}}}

=== reverse() ===

Makes a copy of this string, with all the characters backwards.

{{{
 #!ruby
 "Rocky Dennis".reverse
   #=> "sinneD ykcoR"
}}}

=== scan( pattern: a Regexp ) ===

Goes through this string, trying to match the regular expression as many times
as it can.  You get back an Array of matches.

So, for example, to get a list of all the words in a string:

{{{
 #!ruby
 "Two turntables and a microphone".downcase.scan(/\w+/)
   #=> ["two", "turntables", "and", "a", "microphone"]
}}}

This is a very powerful method and often forgotten!  Say you want to find how
many times the name "George" shows up in a string:

{{{
 #!ruby
 str.scan(/George/i).length
   #=> 4
}}}

The `i` at the end of the Regexp means '''case-insensitive'''.  So it'll
match upper and lowercase "george".

=== split( token: a String ) ===

This will break your string into pieces, into an Array.  And the axe is
laid on a `token`.  Often this is something like a comma or a colon or
something.

{{{
 #!ruby
 "Jeff, Jim, Jillian".split(",")
   #=> ["Jeff", " Jim", " Jillian"]
}}}

You can also split on a regular expression.  So, for example, we might
want to get rid of those spaces before each name:

{{{
 #!ruby
 "Jeff, Jim, Jillian".split(/\s*,\s*/)
   #=> ["Jeff", "Jim", "Jillian"]
}}}

Now the spaces before Jim and Jillian are gone!

=== starts?( beginning: a String ) ===

Does this string start with this `beginning`?  This is great
when used in combination with the `remove` method.  Like if you
want to invent your own chat commands.

{{{
 #!ruby
 "map:Seattle, WA".starts?("map:")
   #=> true
 "map:Seattle, WA".remove("map:")
   #=> "Seattle, WA"
}}}

In your chat program, you'll want to check for any time you
type in "map:An Address".  And then you'll want to send that
map to the chat channel using an Address object.

{{{
 #!ruby
 if cmd.starts?("map:")
   # A map was found!
   addr = Address(cmd.remove("map:"))
   chan.say(addr)
 else
   # Normal talking, just say it.
   chan.say(cmd)
 end
}}}

=== strip() ===

Remove any spaces, tabs or new lines at the beginning and end of a string,
then give back a copy.

=== to_i() ===

Tries to turn this string into a number

{{{
 #!ruby
 "23".to_i
   #=> 23
 "02-Blueberry_Boat.mp3".to_i
   #=> 2
}}}

Notice that second example.  Since the MP3 name starts with a number,
the `to_i` method will go ahead and use that as the number.

=== to_sym() ===

Creates a symbol named identically to this string.  See the `Symbol` page for
more on why symbols are nice.

{{{
 #!ruby
 "Feed".to_sym
   #=> :Feed
}}}

While any string can be turned into a string, you shouldn't turn large strings
into symbols.  Such things can really throw a wrench in the works.

=== upcase() ===

Makes a new string from this string, but with all the lower-case letters
in the string changed to upper-case.  "a" becomes "A",
"b" becomes "B", and so on.

== Symbol ==

A Symbol is a very, very simple kind of String.  Symbols make the code look a bit
prettier.  Rather than having to quote small words, just stick a colon in front of
the word and you have a `:symbol`!

Symbols are pretty primitive, so you'll generally want to stay away from using them
when you can use a string.

There are two really good reasons to use a symbol:

'''As a Hash key.'''  Symbols just look much nicer as hash keys.

{{{
 #!ruby
 book = {:title => "Mother Night", :author => "Kurt Vonnegutt"}
}}}

See how easy it is to see the keys when they're symbols?  If you have string keys
in there, the quotes become sort of overpowering.  You can certainly use strings,
if you don't care, but most people think symbols just look nicer there.

{{{
 #!ruby
 book[:title]
   #=> "Mother Night"
}}}

This also applies when you're using methods that have a Hash-like style.

{{{
 #!ruby
 Web.fetch("metafilter.com", :as => Web::Feed)
}}}

'''In class definitions.'''  This is for more advanced users.  But sometimes you'll
be using methods like `attr_accessor` or `define_method`.  And these methods also
look better with symbols.

{{{
 #!ruby
 class Creature
   attr_accessor :life, :strength, :charisma, :weapon
 end
}}}

So, in a nutshell: symbols are great for Hash keys or when seen in class definitions
and are really just used to make the code look nicer.

=== to_s() ===

Make a string that has the symbol's name inside.

{{{
 #!ruby
 :Feed.to_s
   #=> "Feed"
}}}

== Time ==

A Time object contains a specific date and time, right down to the milliseconds.
And with time zone information.

You can always get the current time with `Time.now`!

{{{
 Time.now
   #=> Mon Apr 16 09:10:01 -0400 2007
}}}

You'll also see times used for Channel messages in Hackety Hack.
Like in a Channel message, the `at` method gets a time when the message
was sent.

{{{
 #!ruby
 chan.hear.each do |m|
   puts m.at
 end
}}}

Usually you won't want to change Time objects.  You'll just want to turn
them into strings.  Time objects have a bunch of different formats.

{{{
 #!ruby
 Time.now.calendar
   #=> "April 16th, 2007"
 Time.now.calendar_with_time
   #=> "April 16th, 2007 at 6:27 PM"
 Time.now.time_only
   #=> "6:27 PM"
 Time.now.quick
   #=> "Apr 16, 2007 at 6:27pm"
 Time.now.short
   #=> "2007-04-16"
 Time.now.full
   #=> "2007-04-16 18:27:57"
}}}

Another common one is the `since` method, which shows how long ago a
moment was.

{{{
 #!ruby
 Time.local(2001, 9, 11).since
   #=> "5 years"
 Time.now.since
   #=> "less than a minute"
}}}

=== Time.local( year, month, day, hour, minute, second, millisecond ) ===

Create a new Time object for your local time zone.  This method takes
a bunch of numbers, starting with the `year` and going down to the
`millisecond`.

{{{
 #!ruby
 Time.local(2007)
   #=> Mon Jan 01 00:00:00 -0400 2007
 Time.local(2001, 9, 11)
   #=> Tue Sep 11 00:00:00 -0400 2001
}}}

As you can see, you can leave numbers out.  If you only give one number,
it'll assume the first day and first second of that year.  If you give
four numbers, Ruby will give you the first second in that hour for
that date.

=== Time.now() ===

Gives the current time.  Right now.

=== calendar() ===

Turns the time into a string of the format "Month Day, Year".
This is designed to be a very readable date, like you'd read
on a newspaper or a calendar.

{{{
 #!ruby
 Time.now.calendar
   #=> "April 16th, 2007"
}}}

=== calendar_with_time() ===

The calendar date from the `calendar` method with the clock
time at the end.

{{{
 #!ruby
 Time.now.calendar_with_time
   #=> "April 16th, 2007 at 6:27 PM"
}}}

=== full() ===

A full date string, small as possible, of the format:
YEAR-MONTH-DATE HOUR:MINUTE:SECONDS.  Clock time is
in 24-hour format. 

{{{
 #!ruby
 Time.now.full
   #=> "2007-04-16 18:27:57"
}}}

=== quick() ===

A full date string with an abbreviated month name and limited
spacing.  Great for blogs and forums, dates that must be compact.

{{{
 #!ruby
 Time.now.quick
   #=> "Apr 16, 2007 at 6:27pm"
}}}

=== short() ===

A shortened date of the format YEAR-MONTH-DAY.

{{{
 #!ruby
 Time.now.short
   #=> "2007-04-16"
}}}

=== time_only() ===

Builds a string of the clock time, with AM and PM, and without the
day, month or year.

{{{
 #!ruby
 Time.now.time_only
   #=> "6:27 PM"
}}}

=== zone() ===

The name of the timezone this Time object represents.

{{{
 #!ruby
 Time.now.zone
   #=> "EST"
}}}

== URI ==

A URI is a web address.  You may find yourself dealing with URIs (also called URLs) on
occassion and this class makes it all a bit easier.

For example, sometimes you've got to take a URI apart.  Take this Google search, for
instance:

{{{
 http://www.google.com/search?hl=en&q=Hackety+Hack&btnG=Search
}}}

This is a mess!  You can hardly make out any of it.  Let's take it
apart:

{{{
 #!ruby
 uri = URI("http://www.google.com/search?hl=en&q=Hackety+Hack&btnG=Search")
 puts uri.host
   #=> "www.google.com"
 puts uri.path
   #=> "/search"
 puts uri['q']
   #=> "Hackety Hack"
}}}

Much better!  There you can see the `host` and `path` of the URI.  The best
part is last line, where the `q` key is taken from the URI.
The `q` key is the part of the Google string where the search terms are kept.

Another example is YouTube URIs:

{{{
 http://youtube.com/watch?v=on7btklYzX4
}}}

The `v` key in the URI holds the video's code:

{{{
 #!ruby
 uri = URI("http://youtube.com/watch?v=on7btklYzX4")
 puts uri['v']
   #=> "on7btklYzX4"
}}}

= The Web library =

The Web library contains methods for downloading files and grabbing information from the Web.

While actually quite tiny, the Web library packs a punch:

 * '''Download methods''' which will save files from the Internet or read blog feeds.
 * '''Search methods''' for getting search results from Google and Yahoo.
 * Or, the '''Web Page classes''' for making your own web pages and popups quickly.

== Download ==

Downloading files and reading blogs is a cinch in Hackety Hack.  Usually it's only one
line of Web.download or Web.fetch.

One really fantastic line is the blog reader:

{{{
 #!ruby
 blog = Web.fetch("http://rubyinside.com", :as => Web::Feed)
}}}

This line of code will visit the blog address and try to find its RSS feed.  RSS stands
for [[http://en.wikipedia.org/wiki/RSS Really Simple Syndication]] and its a file that
most blogs have which contains the latest posts on that blog.

Once you've got the blog feed, you can cycle through the entries:

{{{
 #!ruby
 blog.items.each do |item|
   puts "Title: #{item.title}"
   puts "Link: #{item.link}"
   puts item.description
 end
}}}

=== Web.download( url: a String , save_as: a String ) ===

If you'd like to save a file from the Web to your computer, use Web.download with two arguments.  The first is a URL to the file on the web.  The second argument is a name for the file on your computer.

{{{
 #!ruby
 Web.download("http://example.org/songs/Y-Fford-Oren.mp3", "y-fford-oren.mp3")
}}}

=== Web.fetch( url: a String ) ===

If you'd like to grab a web page and store it in a variable, use `Web.fetch`.

{{{
 #!ruby
 google = Web.fetch("http://google.com/search")
}}}

Should Web.fetch encounter an RSS or XML feed, you will be handed back a Web::Feed object containing the news items.
If Web.fetch encounters a JSON file, you'll get back the object inside that JSON file.

== Search ==

Searching is such a big part of the Web.  These two methods, Web.google and Web.yahoo, let you hook
the search engines right into your program.

You can even write your own custom search engines to search only certain sites.  Both the `Web.google`
and `Web.yahoo` methods have a `:site` key that can be given a list of sites to search:

{{{
 #!ruby
 Web.google( "hackety hack", :site => ["redhanded.hobix.com", "rubyinside.com"])
   #=> [(Web::Feed::Item), (Web::Feed::Item), ...]
}}}

=== Web.google( search: a String ) ===

Do a Google search.  Pass in a string with your search words in it (or an array of search words) and
get back an array of the search results.  The results are all in Web::Item format (just like you see
in blog feeds.)

{{{
 #!ruby
 Web.popup do
   Web.google("hackety hack").each do |item|
     title item.title
     link_to item.link
     para item.description
   end
 end
}}}

This search offers a few keys you can use to enhance your search:

 * `:exact` will search for the words in the exact order they are in the string.[[BR]]
   (Example: `:exact => true`)
 * `:limit` tells the search how many search results to get.[[BR]]
   (Example: `:limit => 30`)
 * `:page` gets the 2nd, 3rd, 4th page of the search, etc.
   (Example: `:page => 2`)
 * `:site` search only a list of sites you provide.[[BR]]
   (Example: `:site => ["digg.com", "slashdot.org"]`)

=== Web.yahoo( search: a String ) ===

Do a Yahoo! search.  Pass in the search words as a string.  Get back an Array of Web::Items.  Just like
Web.google described above.

{{{
 #!ruby
 puts Web.yahoo("hackety hack")
}}}

This search offers a few keys you can use to enhance your search:

 * `:exact` will search for the words in the exact order they are in the string.[[BR]]
   (Example: `:exact => true`)
 * `:limit` tells the search how many search results to get.[[BR]]
   (Example: `:limit => 30`)
 * `:page` gets the 2nd, 3rd, 4th page of the search, etc.
   (Example: `:page => 2`)
 * `:site` search only a list of sites you provide.[[BR]]
   (Example: `:site => ["digg.com", "slashdot.org"]`)

== Pages ==

Makes HTML pages from scratch.

=== Web.page { ... } ===

Since Hackety Hack is built on top of a browser, you can build web pages on the hidden program page.  ''Need to come up with a way to explain all this...''

{{{
 #!ruby
 Web.page {
   h1 'My links'
   ul {
     li { a 'Google', :href => 'http://google.com' }
     li { a 'Hackety Hack', :href => 'http://code.whytheluckystiff.net/hacketyhack/' }  
   }
 }
}}}

=== Web.popup { ... } ===

Opens an in-browser popup.  Inside the block, create the popup contents just as described in `Web.page` above.

{{{
 #!ruby
 Web.popup {
   h1 'Are you sure?'
   buttons { cancel; save }
 }
}}}

=== Web.popup( name: a String ) { ... } ===

This is a variation on the in-browser popup above.  You still create a popup from inside the block.

The difference is the string passed into the method.  The string will be used to attach the popup
to a Table.

{{{
 #!ruby
 Web.popup("Blog") do
   title "Add a Blog Entry"
   editline "Title"
   editbox
   buttons { cancel; save }
 end
}}}

In this example, the popup stores its information in the `Blog` table.  Two things will be stored
in the table: the `editline` called "Title" and the `editbox`, which will be called "Editbox".  If the
table doesn't exist, it'll be created from the popup.

Also see the Table help section for more on working with tables.

